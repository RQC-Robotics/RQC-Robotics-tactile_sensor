# Документация, спецификация, контракты
---
---

для модуля предсказания профиля давления по сенсору с последовательности сигналов(видео)

## Модели устроены так:
в качестве аргументов forward принимает 3 тензора
**(карта давлений на предыдущем шаге, сигнал на предыдущем шаге, сингал на текущем шаге)**

**(predictions[i-1], signals[i-1], signals[i])**

Каждый тензор может быть тензором из таких элементов.
Все эврика вроде производной сигналов, логарифмов пропускания, применение наивной модели к каждому из сигналов, хоть выкидывание всего, кроме текущего сигнала будет реализовываться внутри модели. Такой интерфейс позволяет любое поведение реализовать.


## Обучение
Обучение должно происходить тоже на последовательности кадров разной длины. Для этого существует сущность **subdataloader**, которая инициализируется несколькими последовательностями кадров (chain-ами) и которая для каждого запуска модели формирует батч, описанный в пункте про модели.

Все данные будут храниться в формате видеороликов и соответствующих им файлов с последовательностями сигналов.
Датасет цепочек разной длины из этих видео (**video_dataset**) будет инициализироваться названиями файлов. Также содержит функцию для для разделения всех видеозаписей из обучающей выборки на последовательности длины **chain_len**. 
После запуска такой функции. По нему можно будет итерироваться с помощью torch.Dataloader и получить batch_size цепочек, передать их sub_dataloader-у, который уже по batch_size кадров будет передавать это модели, группируя данные в тот формат, под который специализируются модели.

## Dinamic_video_dataset
При создании нужно указать путь к папке с видео и с сигналами соответствующими. За видео принимает все файлы в папке и рекурентно подпапках. Однократно загружает все видео для определения и запоминания их длин.
Поддерживает функцию **split_to_chains(chain_len)** которая сохраняет массив из псеводоуказателей на массивы.
Сейчас думаю, что обучающие видео будут не слишком длинными, но их будет много, так что лучше для каждой цепи подгружать целое видео в оперативную память, а не загрузить сразу все видео.

После использования функции split_to_chains будет доступно обращение по индексу к конкретной цепочке. Как загружается пара (цепочка, сигнал с цепочки)

## Video_dataset

Версия датасета, которая загружает при инициализации все данные в оперативную память и дальше использует ее оттуда.

Поддерживает функцию **split_to_chains(chain_len)** которая сохраняет массив из псеводоуказателей на массивы.


После использования функции split_to_chains будет доступно обращение по индексу к конкретной цепочке. Как загружается пара (цепочка, сигнал с цепочки)

## Subdataloader

Инициализируется несколькими последовательностями кадров (chain-ами)\
(тензором **(batch_size, chain_len, signals_shape)**) 


для каждого запуска модели формирует батч, описанный в пункте про модели. \
**(predictions[i-1], signals[i-1], signals[i])** Где каждый элемент - массив длиной batch_size
Для этого после каждого вызова функцией **get_next_batch** батча из subdataloader-а нужно функцией **set_previous_pressure** передать результат работы модели, чтобы он был засунут в следующий батч.


# Функции для работы с моделями
## predict
(модель, последовательности сигналов в формате numpy)
(опционально начальные карты давлений для каждого chain-а, по умолчанию будут нули)
Тут инициализируется subdataloader и без градиентов по одному счатаются все новые и новые кадры. Потом конкатенируются и возвращается numpy массив.

## fit_epoch
(модель, video_dataset, criterion, optimizer, chain_len, batch_size)\
Запускает даталоадер по video_dataset, и с каждым input-ом из батча chain-ов запускает функцию **predict_chain_batch**, но только начиная со второго сигнала. А первое давление из каждой цепи сообщается функции predict_chain_batch. Потом сравнивает с помощью критерия с output-ом из батча и делает шаг оптимизатора.

## predict_chain_batch 
(модель, chain_batch, initial_pressure)\
очень похоже на predict, но другое назначение, так что пусть будет чуть-чуть копипасты.

создает subdataloader по chain_batch и правильным образом по ней итерируется. Возвращает конкатенированные давления.


## eval_video

запускает видео через sub-dataloader и возвращает лосс на одном видео.
Нужна, чтобы понимать с какими видео проблемы.
(можно обойтись следующей с video dataset из одного видео, но тогда придется руками подбирать chain_len)

## eval_epoch
принимает test_video_dataset и считает лосс с заданным chain_len